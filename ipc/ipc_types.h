#pragma once

#ifndef IPC_IPC_TYPES_H_
#define IPC_IPC_TYPES_H_

#include <cstdint>

namespace ipc {

// IPC protocol version.
constexpr int32_t VERSION = 0;

// Offset representing a null pointer in the IPC heap.
constexpr uint32_t NULL_OFFSET = ~static_cast<uint32_t>(0);


// Header of the IPC shared memory. It must be present at offset 0.
struct alignas(64) SharedMemoryHeader {
	int8_t magic[4] = { 'a', 'v', 's', 'w' };
	// Size of the entire shared memory region.
	uint32_t size = 0;
	// IPC protocol version.
	int32_t version = VERSION;
	// Offset from SharedMemoryHeader to the master->slave queue.
	uint32_t master_queue_offset = NULL_OFFSET;
	// Offset from SharedMemoryHeader to the slave->master queue.
	uint32_t slave_queue_offset = NULL_OFFSET;
	// Offset from SharedMemoryHeader to the IPC heap.
	uint32_t heap_offset = NULL_OFFSET;
};

// Unidirectional command queue. The queue buffer immediately follows.
struct alignas(64) Queue {
	int8_t magic[4] = { 'c', 'm', 'd', 'q' };
	// Size of the queue and subsequent command buffer.
	uint32_t size = 0;
	// Win32 event used by the reader to wait for commands.
	uint32_t event_handle = 0;
	// Win32 mutex protecting the queue.
	uint32_t mutex_handle = 0;
	// Offset from Queue to the command buffer.
	uint32_t buffer_offset = sizeof(Queue);
	// Number of bytes in use in the buffer, up to (size - sizeof(Queue)).
	uint32_t buffer_usage = 0;
	// Offset from command buffer to reader position.
	uint32_t read_pos = 0;
	// Offset from command buffer to writer position.
	uint32_t write_pos = 0;
};

// Command object in queue. The command payload immediately follows.
struct alignas(8) Command {
	int8_t magic[4] = { 'c', 'm', 'd', 'x' };
	// Size of the command and subsequent payload.
	uint32_t size = 0;
	// ID generated by the sender used to wait for a response.
	uint32_t transaction_id;
	// ID generated by the recipient that resulted in the command.
	uint32_t response_id;
	// Command type. Defined in ipc_client.h.
	int32_t type;
};

// Heap for memory allocation. The heap buffer immediately follows.
struct alignas(64) Heap {
	int8_t magic[4] = { 'h', 'e', 'a', 'p' };
	// Size of the heap and subsequent buffer.
	uint32_t size = 0;
	// Win32 mutex proteccting the heap.
	uint32_t mutex_handle = 0;
	// Offset from Heap to buffer.
	uint32_t buffer_offset = sizeof(Heap);
	// Number of bytes allocated, up to (size - sizeof(Heap)).
	uint32_t buffer_usage = 0;
	// Hint offset from base of buffer to a free block.
	uint32_t last_free_offset = 0;
};


// Heap block is allocated.
constexpr uint32_t HEAP_FLAG_ALLOCATED = 1;

struct alignas(64) HeapNode {
	int8_t magic[4] = { 'm', 'e', 'm', 'z' };
	uint32_t prev_node_offset = NULL_OFFSET;
	uint32_t next_node_offset = NULL_OFFSET;
	uint32_t flags = 0;
};


// Read available commands from queue. The buffer must be at least
// (queue->buffer_usage) bytes. The caller must be holding the queue mutex.
void queue_read(Queue *queue, void *buf);

// Write commands into queue. The caller must be holding the queue mutex.
void queue_write(Queue *queue, const void *buf, uint32_t size);

// Allocate a block from heap. The caller must be holding the heap mutex.
HeapNode *heap_alloc(Heap *heap, uint32_t size);

// Return a block to heap. The caller must be holding the heap mutex.
void heap_free(Heap *heap, HeapNode *node);


inline bool check_fourcc(const int8_t lhs[4], const char rhs[])
{
	return lhs[0] == rhs[0] && lhs[1] == rhs[1] && lhs[2] == rhs[2] && lhs[3] == rhs[3];
}

template <class T, class U>
T *offset_to_pointer(U *base, uint32_t offset)
{
	return (T *)((unsigned char *)base + offset);
}

inline uint32_t pointer_to_offset(const void *base, const void *ptr)
{
	return static_cast<uint32_t>(static_cast<const unsigned char *>(ptr) - static_cast<const unsigned char *>(base));
}

} // namespace ipc

#endif // IPC_IPC_TYPES_H_
